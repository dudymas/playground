package set

import (
	"testing"

	. "github.com/smartystreets/goconvey/convey"
)

func TestSet(t *testing.T) {
	Convey("given an empty set", t, func() {
		empty := NewSet()
		Convey("it reports as empty", func() {
			So(empty.IsEmpty(), ShouldBeTrue)
		})
		Convey("it reports it's size as 0", func() {
			So(empty.Cardinality(), ShouldEqual, 0)
		})
		Convey("it can be cleared", func() {
			empty.Clear()
			So(empty.Cardinality(), ShouldEqual, 0)
		})
	})
	Convey("given an set with a single element", t, func() {
		one := NewSet()
		one.Add("a")
		Convey("it reports as not empty", func() {
			So(one.IsEmpty(), ShouldBeFalse)
		})
		Convey("it reports it's size as 1", func() {
			So(one.Cardinality(), ShouldEqual, 1)
		})
		Convey("it contains it's element", func() {
			So(one.Contains("a"), ShouldBeTrue)
		})
	})
	Convey("given a set with many elements", t, func() {
		many := NewSet()
		many.Add("a")
		many.Add("b")
		Convey("it reports as not empty", func() {
			So(many.IsEmpty(), ShouldBeFalse)
		})
		Convey("it reports it's size as > 1", func() {
			So(many.Cardinality(), ShouldBeGreaterThan, 1)
		})
		Convey("it doesn't add duplicates", func() {
			many.Add("a")
			many.Add("b")
			So(many.Cardinality(), ShouldEqual, 2)
		})
		Convey("it contains it's elements", func() {
			So(many.Contains("a"), ShouldBeTrue)
			So(many.Contains("b"), ShouldBeTrue)
		})
		Convey("it can delete it's elements", func() {
			many.Delete("a")
			So(many.Contains("a"), ShouldBeFalse)
			So(many.Cardinality(), ShouldEqual, 1)
			many.Delete("b")
			So(many.Contains("b"), ShouldBeFalse)
			So(many.Cardinality(), ShouldEqual, 0)
		})
		Convey("it can be cleared", func() {
			many.Clear()
			So(many.Cardinality(), ShouldEqual, 0)
		})
	})
	Convey("given two disjoint sets", t, func() {
		set1, set2 := NewSet(), NewSet()
		set1.Add("a")
		set1.Add("b")
		set2.Add("y")
		set2.Add("z")
		Convey("they can compute thier union", func() {
			union := set1.Union(set2)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Contains("y"), ShouldBeTrue)
			So(union.Contains("z"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 4)
			union = set2.Union(set1)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Contains("y"), ShouldBeTrue)
			So(union.Contains("z"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 4)
		})
		Convey("they can compute thier intersection", func() {
			intersection := set1.Intersection(set2)
			So(intersection.Cardinality(), ShouldEqual, 0)
			intersection = set2.Intersection(set1)
			So(intersection.Cardinality(), ShouldEqual, 0)
		})
		Convey("they can compute thier difference", func() {
			difference := set1.Difference(set2)
			So(difference.Contains("a"), ShouldBeTrue)
			So(difference.Contains("b"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 2)
			difference = set2.Difference(set1)
			So(difference.Contains("y"), ShouldBeTrue)
			So(difference.Contains("z"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 2)
		})
		Convey("they can compute thier symmetric difference", func() {
			difference := set1.SymmetricDifference(set2)
			So(difference.Contains("a"), ShouldBeTrue)
			So(difference.Contains("b"), ShouldBeTrue)
			So(difference.Contains("y"), ShouldBeTrue)
			So(difference.Contains("z"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 4)
			difference = set2.SymmetricDifference(set1)
			So(difference.Contains("a"), ShouldBeTrue)
			So(difference.Contains("b"), ShouldBeTrue)
			So(difference.Contains("y"), ShouldBeTrue)
			So(difference.Contains("z"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 4)
		})
		Convey("they report as not being subsets of each other", func() {
			So(set1.IsSubset(set2), ShouldBeFalse)
			So(set2.IsSubset(set1), ShouldBeFalse)
		})
		Convey("they report as not being supersets of each other", func() {
			So(set1.IsSuperset(set2), ShouldBeFalse)
			So(set2.IsSuperset(set1), ShouldBeFalse)
		})
	})
	Convey("given two overlapping sets", t, func() {
		set1, set2 := NewSet(), NewSet()
		set1.Add("a")
		set1.Add("b")
		set2.Add("b")
		set2.Add("c")
		Convey("they can compute thier union", func() {
			union := set1.Union(set2)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Contains("c"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 3)
			union = set2.Union(set1)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Contains("c"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 3)
		})
		Convey("they can compute thier intersection", func() {
			intersection := set1.Intersection(set2)
			So(intersection.Contains("a"), ShouldBeFalse)
			So(intersection.Contains("b"), ShouldBeTrue)
			So(intersection.Contains("c"), ShouldBeFalse)
			So(intersection.Cardinality(), ShouldEqual, 1)
			intersection = set2.Intersection(set1)
			So(intersection.Contains("a"), ShouldBeFalse)
			So(intersection.Contains("b"), ShouldBeTrue)
			So(intersection.Contains("c"), ShouldBeFalse)
			So(intersection.Cardinality(), ShouldEqual, 1)
		})
		Convey("they can compute thier difference", func() {
			difference := set1.Difference(set2)
			So(difference.Contains("a"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 1)
			difference = set2.Difference(set1)
			So(difference.Contains("c"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 1)
		})
		Convey("they can compute thier symmetric difference", func() {
			difference := set1.SymmetricDifference(set2)
			So(difference.Contains("a"), ShouldBeTrue)
			So(difference.Contains("c"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 2)
			difference = set2.SymmetricDifference(set1)
			So(difference.Contains("a"), ShouldBeTrue)
			So(difference.Contains("c"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 2)
		})
		Convey("they report as not being subsets of each other", func() {
			So(set1.IsSubset(set2), ShouldBeFalse)
			So(set2.IsSubset(set1), ShouldBeFalse)
		})
		Convey("they report as not being supersets of each other", func() {
			So(set1.IsSuperset(set2), ShouldBeFalse)
			So(set2.IsSuperset(set1), ShouldBeFalse)
		})
	})
	Convey("given a set that is a subset of another set", t, func() {
		set1, set2 := NewSet(), NewSet()
		set1.Add("a")
		set1.Add("b")
		set2.Add("a")
		set2.Add("b")
		set2.Add("c")
		Convey("they can compute thier union", func() {
			union := set1.Union(set2)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Contains("c"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 3)
			union = set2.Union(set1)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Contains("c"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 3)
		})
		Convey("they can compute thier intersection", func() {
			intersection := set1.Intersection(set2)
			So(intersection.Contains("a"), ShouldBeTrue)
			So(intersection.Contains("b"), ShouldBeTrue)
			So(intersection.Contains("c"), ShouldBeFalse)
			So(intersection.Cardinality(), ShouldEqual, 2)
			intersection = set2.Intersection(set1)
			So(intersection.Contains("a"), ShouldBeTrue)
			So(intersection.Contains("b"), ShouldBeTrue)
			So(intersection.Contains("c"), ShouldBeFalse)
			So(intersection.Cardinality(), ShouldEqual, 2)
		})
		Convey("they can compute thier difference", func() {
			difference := set1.Difference(set2)
			So(difference.Cardinality(), ShouldEqual, 0)
			difference = set2.Difference(set1)
			So(difference.Contains("c"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 1)
		})
		Convey("they can compute thier symmetric difference", func() {
			difference := set1.SymmetricDifference(set2)
			So(difference.Contains("c"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 1)
			difference = set2.SymmetricDifference(set1)
			So(difference.Contains("c"), ShouldBeTrue)
			So(difference.Cardinality(), ShouldEqual, 1)
		})
		Convey("they report as being subsets of each other", func() {
			So(set1.IsSubset(set2), ShouldBeTrue)
			So(set2.IsSubset(set1), ShouldBeFalse)
		})
		Convey("they report as being supersets of each other", func() {
			So(set1.IsSuperset(set2), ShouldBeFalse)
			So(set2.IsSuperset(set1), ShouldBeTrue)
		})
	})
	Convey("given two identical sets", t, func() {
		set1, set2 := NewSet(), NewSet()
		set1.Add("a")
		set1.Add("b")
		set2.Add("a")
		set2.Add("b")
		Convey("they can compute thier union", func() {
			union := set1.Union(set2)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 2)
			union = set2.Union(set1)
			So(union.Contains("a"), ShouldBeTrue)
			So(union.Contains("b"), ShouldBeTrue)
			So(union.Cardinality(), ShouldEqual, 2)
		})
		Convey("they can compute thier intersection", func() {
			intersection := set1.Intersection(set2)
			So(intersection.Contains("a"), ShouldBeTrue)
			So(intersection.Contains("b"), ShouldBeTrue)
			So(intersection.Cardinality(), ShouldEqual, 2)
			intersection = set2.Intersection(set1)
			So(intersection.Contains("a"), ShouldBeTrue)
			So(intersection.Contains("b"), ShouldBeTrue)
			So(intersection.Cardinality(), ShouldEqual, 2)
		})
		Convey("they can compute thier difference", func() {
			difference := set1.Difference(set2)
			So(difference.Cardinality(), ShouldEqual, 0)
			difference = set2.Difference(set1)
			So(difference.Cardinality(), ShouldEqual, 0)
		})
		Convey("they can compute thier symmetric difference", func() {
			difference := set1.SymmetricDifference(set2)
			So(difference.Cardinality(), ShouldEqual, 0)
			difference = set2.SymmetricDifference(set1)
			So(difference.Cardinality(), ShouldEqual, 0)
		})
		Convey("they report as being subsets of each other", func() {
			So(set1.IsSubset(set2), ShouldBeTrue)
			So(set2.IsSubset(set1), ShouldBeTrue)
		})
		Convey("they report as being supersets of each other", func() {
			So(set1.IsSuperset(set2), ShouldBeTrue)
			So(set2.IsSuperset(set1), ShouldBeTrue)
		})
	})
	Convey("given very large sets", t, func() {
		set1, set2 := NewSet(), NewSet()
		// TODO: this number can be ramped up during CI
		count := 100000
		overlap := 10
		for i := 0; i < count; i++ {
			set1.Add(i)
			set2.Add(i + count - overlap)
		}
		Convey("they can compute thier union", func() {
			union := set1.Union(set2)
			So(union.Cardinality(), ShouldEqual, count*2-overlap)
			union = set2.Union(set1)
			So(union.Cardinality(), ShouldEqual, count*2-overlap)
		})
		Convey("they can compute thier intersection", func() {
			intersection := set1.Intersection(set2)
			So(intersection.Cardinality(), ShouldEqual, overlap)
			intersection = set2.Intersection(set1)
			So(intersection.Cardinality(), ShouldEqual, overlap)
		})
		Convey("they can compute thier difference", func() {
			difference := set1.Difference(set2)
			So(difference.Cardinality(), ShouldEqual, count-overlap)
			difference = set2.Difference(set1)
			So(difference.Cardinality(), ShouldEqual, count-overlap)
		})
		Convey("they can compute thier symmetric difference", func() {
			difference := set1.SymmetricDifference(set2)
			So(difference.Cardinality(), ShouldEqual, count*2-overlap*2)
			difference = set2.SymmetricDifference(set1)
			So(difference.Cardinality(), ShouldEqual, count*2-overlap*2)
		})
		Convey("they report as being subsets of each other", func() {
			So(set1.IsSubset(set2), ShouldBeFalse)
			So(set2.IsSubset(set1), ShouldBeFalse)
		})
		Convey("they report as being supersets of each other", func() {
			So(set1.IsSuperset(set2), ShouldBeFalse)
			So(set2.IsSuperset(set1), ShouldBeFalse)
		})
	})
}
